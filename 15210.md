# 15-210: Parallel and Sequential Data Structures and Algorithms

| Category | Difficulty |
|:-:       | :-:        |
| HW       | 6          |
| Exams    | 8          |

This class is an introduction to parallel algorithms and general algorithm design. It is designed to be taken after functional programming (15-150) mainly because the primary language used in the course is SML. However, the material covered in 15-210 is quite different than that of 15-150 and most of the other 100/200-level CS courses. Topics covered the course typically stay the same from semester to semester. Some of the topics include: divide-and-conquer, contraction, graph search, binary search trees, randomized algorithms, heaps, and dynamic programming. 

## What to expect

- **Homework:** Homeworks are weekly assignments that typically consist of a algorithm-heavy programming problem and a set of written questions related to the topics taught that week. The tough part for the programming homeworks is always coming up with the algorithm and the appropriate data types to use. Once you have those things figured out, programming itself is not a major concern (besides the occasional type-check error). Homeworks are SOLO. 
- **Exams:** The difficulty of the problems is around the same as recitation problems and some of the medium-level written homework problems. Exams are quite comprehensive, covering all topics roughly equally. When preparing for exams, it is important to be comfortable applying any of the algorithmic techniques learnt in class. Be ready to come up with algorithms and write pseudocode. Exams are notoriously difficult in 210, and averages tend to be on the lower side.
- **Bucket System** 210 is famous for its bucket system. Essentially, if you get over an 85% on a homework assignment, it is considered a 100%. So essentially, the percentages associated with your homework grades is taken out of 85 rather than 100. 

## How to do well

- First and foremost, go to recitation. If you don't go to recitation, at least make time to do the problems. Recitation problems are comparable to what you'll see in exams and really help solidify your understanding of the difference concepts covered.
- Go to lecture as much as you can. Exam material is not just limited to the Course Notes and recitations. Exam problems have been pulled from lecture references in the past.
- Read the notes! Seriously! The notes are amazingly thorough and improve with each semester. They are chock-full of examples and mini-problems to test your understanding. Best of all, if there is something you don't understand in the notes, you can always post a question related to that content thanks to the Diderot built-in features.
- For exams, do the practice midterms. Figure out what you are bad at. Then, focus on rereading the notes for those sections.
- As you read the notes, try to quiz yourself questions on the content. Every exam includes conceptual questions, and these can be free points for you if you study effectively. 
- Take advantage of office hours. 210 had many TAs (as one of the bigger CS classes) and thus, a ton of office hours. Use them when your stuck.
- Make sure to plan ahead with the homeworks. The worst thing is to wait for the last day to do the programming and get stuck with a silly bug in your code. You cannot get partial credit on programming homeworks if your code doesn't compile. Avoid procrastinating!


## What to watch out for

- There's a general consensus that 210 starts off really hard (excluding the first homework). Be prepared for that. As you get more comfortable applying algorithmic techniques, the class will get easier. 
- Yes, it does have a probability and randomization unit. It's good to be comfortable with probability/expectation basis coming into the course.

## Resources
Office hours, recitation notes, and the Diderot Textbook. There are also a ton of problems online (cough cough Leetcode/GeeksforGeeks) that employ the algorithmic techniques taught in 210. They are a great resource if you are looking for more practice.