# 15/18-213: Introduction to Computer Systems

| Category | Difficulty |
|:-:       | :-:        |
| HW (labs)| 8          |
| Exams    | 7          |

This class is the next big step for programming courses after 15-122, and is
arguably even more time consuming. That being said, 213 can be very rewarding,
as it gives students lots of great experience with complex programming projects
which can be valuable for students when applying for software internships.
The weekly homework assignments (called labs) are the bulk of the work, and are
what the course is built around.

## What to expect

- **Labs:** The labs are what define 213. They take a lot of time and are very involved.
- **HW:** There is no additional homework aside from the weekly labs
- **Exams:** Are pretty challenging, but you have way more time than you need while you take them. Plus, they give you a lot of practice questions that you should take advantage of if you want to do well in the class.

## How to do well

- Skim over the book when you can - it follows along with lecture well b/c professor Bryant wrote it.
  In addition, the book goes over implementations for parts of the HW.
  Overall, the book is very well-written, so use it to your advantage.
- Start the assignments as soon as you can and ask for help at recitation
- Use the practice server for the exams - the questions on the server are very similar to the real exams. 
  If you don't have time to practice all the questions while the exam server is live, you can 
  try to download and compile all the questions beforehand, so you can do them at your own pace.
- Save your late days for the later assignments like `malloc` and `proxy`

## What to watch out for

- If you get a bad TA for your recitation, it is definitely worth the trouble to switch sections. Recitation can be very helpful if you have the right TA
- The lectures can be really boring b/c they usually just go through slides
- If you think you have a creative way of doing one of the assignments in a different way, make absolutely sure that it will work because there's usually a preferred way for each assignment to be done

## For the overachiever

- Later on in the class, you will probably find `gdb` useful as a debugging
  tool to analyze your code when it is not working. As easy and powerful as
  print statements may be, you will definitely find `gdb` extremely useful 
  if you can learn to use it well. It will help you step through code, trace
  where you are at any moment, and overall help you develop stronger debugging skills.
- Learning `vim` and `tmux`. Although there is no requirement to develop on terminal in most CS classes, learning how to work in a terminal environment can be a very useful skill to pick up for lower-level programming classes, and extend into your work. While sublime and visual studio code are easy to use and have nice GUIs, there are more efficient methods to develop in terminal if you set it up right. The setup cost and learning curve is quite steep for doing the in-terminal experience, so many people tend to shy away from it.
- Starting from `malloc`, the course staff starts to stress documentation a lot. They should be teaching it much earlier, as documentation is a very underrated skill that is neglected in many courses at CMU. If possible, you should look into `doxygen` as a framework for you to document your code.
- If you enjoyed 213 a lot, you should consider taking `15-410: Operating Systems`.

## Resources

- [Computer Systems: A Programmer's Perspective, 3/E](https://csapp.cs.cmu.edu/). Textbook used for this class.
- [Operating Systems Concepts](https://codex.cs.yale.edu/avi/os-book/OS9/index.html). If you're looking for more in-depth knowledge about systems. I don't know why they use dinosaurs for their cover, but because of it, people refer to this text as the `dinosaur book`.
- [doxygen](http://www.doxygen.nl/). Documentation.
- [vim as an ide](https://github.com/jez/vim-as-an-ide) This is a bit outdated because people prefer [neovim](https://neovim.io/), but many of the packages are still relevant. Just look out for the `nvim` corresponding versions.